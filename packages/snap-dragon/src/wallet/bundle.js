function getExportWithNestedEvaluate(filePrefix) {
  'use strict';
  // Serialised sources.
  if (filePrefix === undefined) {
    filePrefix = "/bundled-source";
  }
  const moduleFormat = "nestedEvaluate";
  const entrypoint = "packages/snap-dragon/src/wallet/ui.js";
  const sourceBundle = {
  "packages/snap-dragon/src/wallet/ui.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrequire('../../../../node_modules/rollup-plugin-node-builtins/src/es6/stream.js'); /* import './install-ses.js'*/ /* import wsCaptp from 'node-ws-captp';*/ /* const { createServer, createClient } = wsCaptp*/ /* const { createServer, createClient } = require('node-ws-captp');*/ /* const greeting = 'Hello, world!';*/ /* const bootstrap  = {*/ /* greet: async () => greeting,*/ /* };*/ /* const killServer = createServer(bootstrap, 8088);*/ /* createClient*/\n\nmain();\n\nasync function main() {\n  const hostport = '127.0.0.1:8000';\n  const wsurl = `ws://${hostport}/private/captp`;\n  const { E, getBootstrap, abort } = createClient(wsurl);\n\n\n  let bootP = getBootstrap();\n  const loaded = await E.G(bootP).LOADING;\n  log.info('Chain loaded:', loaded);\n  /* Take a new copy, since the chain objects have been added to bootstrap.*/\n  bootP = getBootstrap();}\n\n\n\n\n\n/* const value = await E(getBootstrap()).greet();*/\n\n/* const { getBootstrap, captpStream } = makeCaptpStream() */\n/* const ws = websocket('ws://echo.websocket.org')*/\n\n/* pump(*/\n/* ws,*/\n/* captpStream,*/\n/* ws,*/\n/* (err) => console.log('did close', err)*/\n/* )*/\n\n\n\nconsole.log(window.location);\n\nvar ui = async () => {\n  globalThis.E = E;\n\n  let bootP = getBootstrap();\n  const loaded = await E.G(bootP).LOADING;\n  log.info('Chain loaded:', loaded);\n  /* Take a new copy, since the chain objects have been added to bootstrap.*/\n  bootP = getBootstrap();\n\n  /* const { dispatch, getBootstrap } = makeCapTP('bundle', obj =>*/\n  /* sendJSON(ws, obj),*/\n  /* );*/\n\n  /* Wait for the chain to become ready.*/\n  /* let bootP = getBootstrap();*/\n  /* const loaded = await E.G(bootP).LOADING;*/\n  /* log.info('Chain loaded:', loaded);*/\n  /* // Take a new copy, since the chain objects have been added to bootstrap.*/\n  /* bootP = getBootstrap();*/\n\n  /* const obj = JSON.parse(data);*/\n  /* log.debug('receiving', data.slice(0, 200));*/\n  /* if (obj.type === 'CTP_ERROR') {*/\n  /* throw obj.error;*/\n  /* }*/\n  /* dispatch(obj);*/\n\n  /* const home = await bootP*/\n\n  /* const wallet = await E.G(home).wallet*/\n  /* const wallet = await E.G(home).wallet*/\n\n  /* wallet*/\n\n  /* const offerP = E(E.G(bootP).wallet).getSendOffer()*/};exports.default = ui;",
  "node_modules/rollup-plugin-node-builtins/src/es6/events.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });'use strict';\n\nvar domain;\n\n/* This constructor is used to store event handlers. Instantiating this is*/\n/* faster than explicitly calling `Object.create(null)` to get a \"clean\" empty*/\n/* object (tested with v8 v4.9).*/\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);}\n\n\n\n\n/* nodejs oddity*/\n/* require('events') === require('events').EventEmitter*/\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n/* By default EventEmitters will print a warning if more than 10 listeners are*/\n/* added to it. This is a useful default which helps finding memory leaks.*/\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function () {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    /* if there is an active domain, then attach to it.*/\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;}}\n\n\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;}\n\n\n  this._maxListeners = this._maxListeners || undefined;};\n\n\n/* Obviously not all Emitters should be limited to 10. This function allows*/\n/* that to be increased. Set to zero for unlimited.*/\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n  throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;};\n\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n  return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;}\n\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);};\n\n\n/* These standalone emit* functions are used to optimize calling of event*/\n/* handlers for fast cases because emit() itself often has a variable number of*/\n/* arguments and can be deoptimized because of that. These functions always have*/\n/* the same number of arguments and thus do not get deoptimized, so the code*/\n/* inside them can execute faster.*/\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n  handler.call(self);else\n  {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n    listeners[i].call(self);}}\n\n\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n  handler.call(self, arg1);else\n  {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n    listeners[i].call(self, arg1);}}\n\n\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n  handler.call(self, arg1, arg2);else\n  {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n    listeners[i].call(self, arg1, arg2);}}\n\n\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n  handler.call(self, arg1, arg2, arg3);else\n  {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n    listeners[i].call(self, arg1, arg2, arg3);}}\n\n\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n  handler.apply(self, args);else\n  {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n    listeners[i].apply(self, args);}}\n\n\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = type === 'error';\n\n  events = this._events;\n  if (events)\n  doError = doError && events.error == null;else\n  if (!doError)\n  return false;\n\n  domain = this.domain;\n\n  /* If there is no 'error' event listener then throw.*/\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n      er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);} else\n    if (er instanceof Error) {\n      throw er; /* Unhandled 'error' event*/} else\n    {\n      /* At least give some kind of context to the user*/\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;}\n\n    return false;}\n\n\n  handler = events[type];\n\n  if (!handler)\n  return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    /* fast cases*/\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    /* slower*/\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);}\n\n\n  if (needDomainExit)\n  domain.exit();\n\n  return true;};\n\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n  throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;} else\n  {\n    /* To avoid recursion in the case that type === \"newListener\"! Before*/\n    /* adding it to the listeners, first emit \"newListener\".*/\n    if (events.newListener) {\n      target.emit('newListener', type,\n      listener.listener ? listener.listener : listener);\n\n      /* Re-assign `events` because a newListener handler could have caused the*/\n      /* this._events to be assigned to a new object*/\n      events = target._events;}\n\n    existing = events[type];}\n\n\n  if (!existing) {\n    /* Optimize the case of one listener. Don't need the extra array object.*/\n    existing = events[type] = listener;\n    ++target._eventsCount;} else\n  {\n    if (typeof existing === 'function') {\n      /* Adding the second element, need to change to array.*/\n      existing = events[type] = prepend ? [listener, existing] :\n      [existing, listener];} else\n    {\n      /* If we've already got an array, just append.*/\n      if (prepend) {\n        existing.unshift(listener);} else\n      {\n        existing.push(listener);}}\n\n\n\n    /* Check for listener leak*/\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n        existing.length + ' ' + type + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);}}}\n\n\n\n\n  return target;}\n\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);};\n\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\nfunction prependListener(type, listener) {\n  return _addListener(this, type, listener, true);};\n\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);}}\n\n\n  g.listener = listener;\n  return g;}\n\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n  throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;};\n\n\nEventEmitter.prototype.prependOnceListener =\nfunction prependOnceListener(type, listener) {\n  if (typeof listener !== 'function')\n  throw new TypeError('\"listener\" argument must be a function');\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;};\n\n\n/* emits a 'removeListener' event iff the listener was removed*/\nEventEmitter.prototype.removeListener =\nfunction removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n\n  if (typeof listener !== 'function')\n  throw new TypeError('\"listener\" argument must be a function');\n\n  events = this._events;\n  if (!events)\n  return this;\n\n  list = events[type];\n  if (!list)\n  return this;\n\n  if (list === listener || list.listener && list.listener === listener) {\n    if (--this._eventsCount === 0)\n    this._events = new EventHandlers();else\n    {\n      delete events[type];\n      if (events.removeListener)\n      this.emit('removeListener', type, list.listener || listener);}} else\n\n  if (typeof list !== 'function') {\n    position = -1;\n\n    for (i = list.length; i-- > 0;) {\n      if (list[i] === listener ||\n      list[i].listener && list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;}}\n\n\n\n    if (position < 0)\n    return this;\n\n    if (list.length === 1) {\n      list[0] = undefined;\n      if (--this._eventsCount === 0) {\n        this._events = new EventHandlers();\n        return this;} else\n      {\n        delete events[type];}} else\n\n    {\n      spliceOne(list, position);}\n\n\n    if (events.removeListener)\n    this.emit('removeListener', type, originalListener || listener);}\n\n\n  return this;};\n\n\nEventEmitter.prototype.removeAllListeners =\nfunction removeAllListeners(type) {\n  var listeners, events;\n\n  events = this._events;\n  if (!events)\n  return this;\n\n  /* not listening for removeListener, no need to emit*/\n  if (!events.removeListener) {\n    if (arguments.length === 0) {\n      this._events = new EventHandlers();\n      this._eventsCount = 0;} else\n    if (events[type]) {\n      if (--this._eventsCount === 0)\n      this._events = new EventHandlers();else\n\n      delete events[type];}\n\n    return this;}\n\n\n  /* emit removeListener for all listeners on all events*/\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    for (var i = 0, key; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);}\n\n    this.removeAllListeners('removeListener');\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n    return this;}\n\n\n  listeners = events[type];\n\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);} else\n  if (listeners) {\n    /* LIFO order*/\n    do {\n      this.removeListener(type, listeners[listeners.length - 1]);} while (\n    listeners[0]);}\n\n\n  return this;};\n\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n  ret = [];else\n  {\n    evlistener = events[type];\n    if (!evlistener)\n    ret = [];else\n    if (typeof evlistener === 'function')\n    ret = [evlistener.listener || evlistener];else\n\n    ret = unwrapListeners(evlistener);}\n\n\n  return ret;};\n\n\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);} else\n  {\n    return listenerCount.call(emitter, type);}};\n\n\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;} else\n    if (evlistener) {\n      return evlistener.length;}}\n\n\n\n  return 0;}\n\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];};\n\n\n/* About 1.5x faster than the two-arg version of Array#splice().*/\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n  list[i] = list[k];\n  list.pop();}\n\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n  copy[i] = arr[i];\n  return copy;}\n\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];}\n\n  return ret;}exports.EventEmitter = EventEmitter;exports.default = EventEmitter;",
  "node_modules/rollup-plugin-node-globals/src/global.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var global$1 = typeof global !== \"undefined\" ? global :\ntypeof self !== \"undefined\" ? self :\ntypeof window !== \"undefined\" ? window : {};exports.default = global$1;",
  "node_modules/buffer-es6/base64.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });\nvar lookup = [];\nvar revLookup = [];\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\nvar inited = false;\nfunction init() {\n  inited = true;\n  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  for (var i = 0, len = code.length; i < len; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;}\n\n\n  revLookup['-'.charCodeAt(0)] = 62;\n  revLookup['_'.charCodeAt(0)] = 63;}\n\n\nfunction toByteArray(b64) {\n  if (!inited) {\n    init();}\n\n  var i, j, l, tmp, placeHolders, arr;\n  var len = b64.length;\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4');}\n\n\n  /* the number of equal signs (place holders)*/\n  /* if there are two placeholders, than the two characters before it*/\n  /* represent one byte*/\n  /* if there is only one, then the three characters before it represent 2 bytes*/\n  /* this is just a cheap hack to not do indexOf twice*/\n  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\n  /* base64 is 4/3 + up to two characters of the original data*/\n  arr = new Arr(len * 3 / 4 - placeHolders);\n\n  /* if there are placeholders, only get up to the last complete 4 chars*/\n  l = placeHolders > 0 ? len - 4 : len;\n\n  var L = 0;\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n    arr[L++] = tmp >> 16 & 0xFF;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;}\n\n\n  if (placeHolders === 2) {\n    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n    arr[L++] = tmp & 0xFF;} else\n  if (placeHolders === 1) {\n    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n    arr[L++] = tmp >> 8 & 0xFF;\n    arr[L++] = tmp & 0xFF;}\n\n\n  return arr;}\n\n\nfunction tripletToBase64(num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];}\n\n\nfunction encodeChunk(uint8, start, end) {\n  var tmp;\n  var output = [];\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output.push(tripletToBase64(tmp));}\n\n  return output.join('');}\n\n\nfunction fromByteArray(uint8) {\n  if (!inited) {\n    init();}\n\n  var tmp;\n  var len = uint8.length;\n  var extraBytes = len % 3; /* if we have 1 byte left, pad 2 bytes*/\n  var output = '';\n  var parts = [];\n  var maxChunkLength = 16383; /* must be multiple of 3*/\n\n  /* go through the array every three bytes, we'll deal with trailing stuff later*/\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));}\n\n\n  /* pad the end with zeros, but make sure to not forget the extra bytes*/\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1];\n    output += lookup[tmp >> 2];\n    output += lookup[tmp << 4 & 0x3F];\n    output += '==';} else\n  if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n    output += lookup[tmp >> 10];\n    output += lookup[tmp >> 4 & 0x3F];\n    output += lookup[tmp << 2 & 0x3F];\n    output += '=';}\n\n\n  parts.push(output);\n\n  return parts.join('');}exports.fromByteArray = fromByteArray;exports.toByteArray = toByteArray;",
  "node_modules/buffer-es6/ieee754.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });\nfunction read(buffer, offset, isLE, mLen, nBytes) {\n  var e, m;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = -7;\n  var i = isLE ? nBytes - 1 : 0;\n  var d = isLE ? -1 : 1;\n  var s = buffer[offset + i];\n\n  i += d;\n\n  e = s & (1 << -nBits) - 1;\n  s >>= -nBits;\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias;} else\n  if (e === eMax) {\n    return m ? NaN : (s ? -1 : 1) * Infinity;} else\n  {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;}\n\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);}\n\n\nfunction write(buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c;\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n  var i = isLE ? 0 : nBytes - 1;\n  var d = isLE ? 1 : -1;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;} else\n  {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;}\n\n    if (e + eBias >= 1) {\n      value += rt / c;} else\n    {\n      value += rt * Math.pow(2, 1 - eBias);}\n\n    if (value * c >= 2) {\n      e++;\n      c /= 2;}\n\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;} else\n    if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;} else\n    {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;}}\n\n\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128;}exports.read = read;exports.write = write;",
  "node_modules/buffer-es6/isArray.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var toString = {}.toString;\n\nvar isArray = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';};exports.default = isArray;",
  "node_modules/buffer-es6/index.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var global = require('../rollup-plugin-node-globals/src/global.js');var base64 = require('./base64.js');var ieee754 = require('./ieee754.js');var isArray = require('./isArray.js');var\n\n\n\n\n\n\n\n\n\n\n\n\nINSPECT_MAX_BYTES = 50; /**\n                         * If `Buffer.TYPED_ARRAY_SUPPORT`:\n                         *   === true    Use Uint8Array implementation (fastest)\n                         *   === false   Use Object implementation (most compatible, even IE6)\n                         *\n                         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n                         * Opera 11.6+, iOS 4.2+.\n                         *\n                         * Due to various browser bugs, sometimes the Object implementation will be used even\n                         * when the browser supports typed arrays.\n                         *\n                         * Note:\n                         *\n                         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n                         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n                         *\n                         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n                         *\n                         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n                         *     incorrect length in some situations.\n                         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n                         * get the Object implementation, which is slower but behaves correctly.\n                         */\n\n\n\nBuffer.TYPED_ARRAY_SUPPORT = global.default.TYPED_ARRAY_SUPPORT !== undefined ?\nglobal.default.TYPED_ARRAY_SUPPORT :\ntrue; /* * Export kMaxLength after typed array support is determined.\n       */var\n\n\n\n_kMaxLength = kMaxLength();\n\nfunction typedArraySupport() {\n  return true; /* rollup issues*/ /* try {*/ /* var arr = new Uint8Array(1)*/ /* arr.__proto__ = {*/ /* __proto__: Uint8Array.prototype,*/ /* foo: function () { return 42 }*/ /* }*/ /* return arr.foo() === 42 && // typed array instances can be augmented*/ /* typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`*/ /* arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`*/ /* } catch (e) {*/ /* return false*/ /* }*/}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction kMaxLength() {\n  return Buffer.TYPED_ARRAY_SUPPORT ?\n  0x7fffffff :\n  0x3fffffff;}\n\n\nfunction createBuffer(that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length');}\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {/* Return an augmented `Uint8Array` instance, for best performance*/\n\n    that = new Uint8Array(length);\n    that.__proto__ = Buffer.prototype;} else\n  {/* Fallback: Return an object instance of the Buffer class*/\n\n    if (that === null) {\n      that = new Buffer(length);}\n\n    that.length = length;}\n\n\n  return that;} /**\n                 * The Buffer constructor returns instances of `Uint8Array` that have their\n                 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n                 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n                 * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n                 * returns a single octet.\n                 *\n                 * The `Uint8Array` prototype remains unmodified.\n                 */\n\n\n\n\nfunction Buffer(arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length);} /* Common case.*/\n\n\n\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n      'If encoding is specified then the first argument must be a string');}\n\n\n    return allocUnsafe(this, arg);}\n\n  return from(this, arg, encodingOrOffset, length);}\n\n\nBuffer.poolSize = 8192; /* not used by this implementation*/ /* TODO: Legacy, not needed anymore. Remove in next major version.*/\n\n\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype;\n  return arr;};\n\n\nfunction from(that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number');}\n\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length);}\n\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset);}\n\n\n  return fromObject(that, value);} /**\n                                    * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n                                    * if value is a number.\n                                    * Buffer.from(str[, encoding])\n                                    * Buffer.from(array)\n                                    * Buffer.from(buffer)\n                                    * Buffer.from(arrayBuffer[, byteOffset[, length]])\n                                    **/\n\n\n\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length);};\n\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype;\n  Buffer.__proto__ = Uint8Array;\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n  Buffer[Symbol.species] === Buffer) {// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    // Object.defineProperty(Buffer, Symbol.species, {\n    //   value: null,\n    //   configurable: true\n    // })\n  }}\n\n\n\nfunction assertSize(size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number');} else\n  if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative');}}\n\n\n\nfunction alloc(that, size, fill, encoding) {\n  assertSize(size);\n  if (size <= 0) {\n    return createBuffer(that, size);}\n\n  if (fill !== undefined) {/* Only pay attention to encoding if it's a string. This*/ /* prevents accidentally sending in a number that would*/ /* be interpretted as a start offset.*/\n\n\n\n    return typeof encoding === 'string' ?\n    createBuffer(that, size).fill(fill, encoding) :\n    createBuffer(that, size).fill(fill);}\n\n  return createBuffer(that, size);} /**\n                                     * Creates a new filled Buffer instance.\n                                     * alloc(size[, fill[, encoding]])\n                                     **/\n\n\n\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding);};\n\n\nfunction allocUnsafe(that, size) {\n  assertSize(size);\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0;}}\n\n\n  return that;} /**\n                 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n                 * */\n\n\n\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size);}; /**\n                                     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n                                     */\n\n\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size);};\n\n\nfunction fromString(that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8';}\n\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding');}\n\n\n  var length = byteLength(string, encoding) | 0;\n  that = createBuffer(that, length);\n\n  var actual = that.write(string, encoding);\n\n  if (actual !== length) {/* Writing a hex string, for example, that contains invalid characters will*/ /* cause everything after the first invalid character to be ignored. (e.g.*/ /* 'abxxcd' will be treated as 'ab')*/\n\n\n\n    that = that.slice(0, actual);}\n\n\n  return that;}\n\n\nfunction fromArrayLike(that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0;\n  that = createBuffer(that, length);\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255;}\n\n  return that;}\n\n\nfunction fromArrayBuffer(that, array, byteOffset, length) {\n  array.byteLength; /* this throws if `array` is not a valid ArrayBuffer*/\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds');}\n\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds');}\n\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array);} else\n  if (length === undefined) {\n    array = new Uint8Array(array, byteOffset);} else\n  {\n    array = new Uint8Array(array, byteOffset, length);}\n\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {/* Return an augmented `Uint8Array` instance, for best performance*/\n\n    that = array;\n    that.__proto__ = Buffer.prototype;} else\n  {/* Fallback: Return an object instance of the Buffer class*/\n\n    that = fromArrayLike(that, array);}\n\n  return that;}\n\n\nfunction fromObject(that, obj) {\n  if (internalIsBuffer(obj)) {\n    var len = checked(obj.length) | 0;\n    that = createBuffer(that, len);\n\n    if (that.length === 0) {\n      return that;}\n\n\n    obj.copy(that, 0, 0, len);\n    return that;}\n\n\n  if (obj) {\n    if (typeof ArrayBuffer !== 'undefined' &&\n    obj.buffer instanceof ArrayBuffer || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0);}\n\n      return fromArrayLike(that, obj);}\n\n\n    if (obj.type === 'Buffer' && isArray.default(obj.data)) {\n      return fromArrayLike(that, obj.data);}}\n\n\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');}\n\n\nfunction checked(length) {/* Note: cannot use `length < kMaxLength()` here because that fails when*/ /* length is NaN (which is otherwise coerced to zero.)*/\n\n\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n    'size: 0x' + kMaxLength().toString(16) + ' bytes');}\n\n  return length | 0;}\n\n\nfunction SlowBuffer(length) {\n  if (+length != length) {/* eslint-disable-line eqeqeq*/\n    length = 0;}\n\n  return Buffer.alloc(+length);}\n\nBuffer.isBuffer = isBuffer;\nfunction internalIsBuffer(b) {\n  return !!(b != null && b._isBuffer);}\n\n\nBuffer.compare = function compare(a, b) {\n  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers');}\n\n\n  if (a === b) return 0;\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;}}\n\n\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;};\n\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true;\n    default:\n      return false;}};\n\n\n\nBuffer.concat = function concat(list, length) {\n  if (!isArray.default(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers');}\n\n\n  if (list.length === 0) {\n    return Buffer.alloc(0);}\n\n\n  var i;\n  if (length === undefined) {\n    length = 0;\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length;}}\n\n\n\n  var buffer = Buffer.allocUnsafe(length);\n  var pos = 0;\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i];\n    if (!internalIsBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers');}\n\n    buf.copy(buffer, pos);\n    pos += buf.length;}\n\n  return buffer;};\n\n\nfunction byteLength(string, encoding) {\n  if (internalIsBuffer(string)) {\n    return string.length;}\n\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (\n  ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength;}\n\n  if (typeof string !== 'string') {\n    string = '' + string;}\n\n\n  var len = string.length;\n  if (len === 0) return 0; /* Use a for loop to avoid recursion*/\n\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len;\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length;\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2;\n      case 'hex':\n        return len >>> 1;\n      case 'base64':\n        return base64ToBytes(string).length;\n      default:\n        if (loweredCase) return utf8ToBytes(string).length; /* assume utf8*/\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;}}}\n\n\n\nBuffer.byteLength = byteLength;\n\nfunction slowToString(encoding, start, end) {\n  var loweredCase = false; /* No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only*/ /* property of a typed array.*/ /* This behaves neither like String nor Uint8Array in that we set start/end*/ /* to their upper/lower bounds if the value passed is out of range.*/ /* undefined is handled specially as per ECMA-262 6th Edition,*/ /* Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.*/\n\n\n\n\n\n\n\n\n  if (start === undefined || start < 0) {\n    start = 0;} /* Return early if start > this.length. Done here to prevent potential uint32*/ /* coercion fail below.*/\n\n\n\n  if (start > this.length) {\n    return '';}\n\n\n  if (end === undefined || end > this.length) {\n    end = this.length;}\n\n\n  if (end <= 0) {\n    return '';} /* Force coersion to uint32. This will also coerce falsey/NaN values to 0.*/\n\n\n\n  end >>>= 0;\n  start >>>= 0;\n\n  if (end <= start) {\n    return '';}\n\n\n  if (!encoding) encoding = 'utf8';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end);\n\n      case 'ascii':\n        return asciiSlice(this, start, end);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end);\n\n      case 'base64':\n        return base64Slice(this, start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;}}} /* The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect*/ /* Buffer instances.*/\n\n\n\n\n\n\nBuffer.prototype._isBuffer = true;\n\nfunction swap(b, n, m) {\n  var i = b[n];\n  b[n] = b[m];\n  b[m] = i;}\n\n\nBuffer.prototype.swap16 = function swap16() {\n  var len = this.length;\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits');}\n\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1);}\n\n  return this;};\n\n\nBuffer.prototype.swap32 = function swap32() {\n  var len = this.length;\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits');}\n\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3);\n    swap(this, i + 1, i + 2);}\n\n  return this;};\n\n\nBuffer.prototype.swap64 = function swap64() {\n  var len = this.length;\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits');}\n\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7);\n    swap(this, i + 1, i + 6);\n    swap(this, i + 2, i + 5);\n    swap(this, i + 3, i + 4);}\n\n  return this;};\n\n\nBuffer.prototype.toString = function toString() {\n  var length = this.length | 0;\n  if (length === 0) return '';\n  if (arguments.length === 0) return utf8Slice(this, 0, length);\n  return slowToString.apply(this, arguments);};\n\n\nBuffer.prototype.equals = function equals(b) {\n  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');\n  if (this === b) return true;\n  return Buffer.compare(this, b) === 0;};\n\n\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max) str += ' ... ';}\n\n  return '<Buffer ' + str + '>';};\n\n\nBuffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n  if (!internalIsBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer');}\n\n\n  if (start === undefined) {\n    start = 0;}\n\n  if (end === undefined) {\n    end = target ? target.length : 0;}\n\n  if (thisStart === undefined) {\n    thisStart = 0;}\n\n  if (thisEnd === undefined) {\n    thisEnd = this.length;}\n\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index');}\n\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0;}\n\n  if (thisStart >= thisEnd) {\n    return -1;}\n\n  if (start >= end) {\n    return 1;}\n\n\n  start >>>= 0;\n  end >>>= 0;\n  thisStart >>>= 0;\n  thisEnd >>>= 0;\n\n  if (this === target) return 0;\n\n  var x = thisEnd - thisStart;\n  var y = end - start;\n  var len = Math.min(x, y);\n\n  var thisCopy = this.slice(thisStart, thisEnd);\n  var targetCopy = target.slice(start, end);\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i];\n      y = targetCopy[i];\n      break;}}\n\n\n\n  if (x < y) return -1;\n  if (y < x) return 1;\n  return 0;}; /* Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,*/ /* OR the last index of `val` in `buffer` at offset <= `byteOffset`.*/ /**/ /* Arguments:*/ /* - buffer - a Buffer to search*/ /* - val - a string, Buffer, or number*/ /* - byteOffset - an index into `buffer`; will be clamped to an int32*/ /* - encoding - an optional encoding, relevant is val is a string*/ /* - dir - true for indexOf, false for lastIndexOf*/\n\n\n\n\n\n\n\n\n\n\n\nfunction bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {/* Empty buffer means no match*/\n\n  if (buffer.length === 0) return -1; /* Normalize byteOffset*/\n\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;} else\n  if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;} else\n  if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;}\n\n  byteOffset = +byteOffset; /* Coerce to Number.*/\n  if (isNaN(byteOffset)) {/* byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer*/\n\n    byteOffset = dir ? 0 : buffer.length - 1;} /* Normalize byteOffset: negative offsets start from the end of the buffer*/\n\n\n\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1;else\n    byteOffset = buffer.length - 1;} else\n  if (byteOffset < 0) {\n    if (dir) byteOffset = 0;else\n    return -1;} /* Normalize val*/\n\n\n\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding);} /* Finally, search either indexOf (if dir is true) or lastIndexOf*/\n\n\n\n  if (internalIsBuffer(val)) {/* Special case: looking for empty string/buffer always fails*/\n\n    if (val.length === 0) {\n      return -1;}\n\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);} else\n  if (typeof val === 'number') {\n    val = val & 0xFF; /* Search for a byte value [0-255]*/\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n    typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);} else\n      {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);}}\n\n\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);}\n\n\n  throw new TypeError('val must be string, number or Buffer');}\n\n\nfunction arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1;\n  var arrLength = arr.length;\n  var valLength = val.length;\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase();\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n    encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1;}\n\n      indexSize = 2;\n      arrLength /= 2;\n      valLength /= 2;\n      byteOffset /= 2;}}\n\n\n\n  function read(buf, i) {\n    if (indexSize === 1) {\n      return buf[i];} else\n    {\n      return buf.readUInt16BE(i * indexSize);}}\n\n\n\n  var i;\n  if (dir) {\n    var foundIndex = -1;\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;} else\n      {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;}}} else\n\n\n  {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true;\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false;\n          break;}}\n\n\n      if (found) return i;}}\n\n\n\n  return -1;}\n\n\nBuffer.prototype.includes = function includes(val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1;};\n\n\nBuffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);};\n\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);};\n\n\nfunction hexWrite(buf, string, offset, length) {\n  offset = Number(offset) || 0;\n  var remaining = buf.length - offset;\n  if (!length) {\n    length = remaining;} else\n  {\n    length = Number(length);\n    if (length > remaining) {\n      length = remaining;}} /* must be an even number of digits*/\n\n\n\n\n  var strLen = string.length;\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');\n\n  if (length > strLen / 2) {\n    length = strLen / 2;}\n\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16);\n    if (isNaN(parsed)) return i;\n    buf[offset + i] = parsed;}\n\n  return i;}\n\n\nfunction utf8Write(buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);}\n\n\nfunction asciiWrite(buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length);}\n\n\nfunction latin1Write(buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length);}\n\n\nfunction base64Write(buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length);}\n\n\nfunction ucs2Write(buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);}\n\n\nBuffer.prototype.write = function write(string, offset, length, encoding) {/* Buffer#write(string)*/\n\n  if (offset === undefined) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0; /* Buffer#write(string, encoding)*/} else\n\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0; /* Buffer#write(string, offset[, length][, encoding])*/} else\n\n  if (isFinite(offset)) {\n    offset = offset | 0;\n    if (isFinite(length)) {\n      length = length | 0;\n      if (encoding === undefined) encoding = 'utf8';} else\n    {\n      encoding = length;\n      length = undefined;} /* legacy write(string, encoding, offset, length) - remove in v0.13*/} else\n\n\n  {\n    throw new Error(\n    'Buffer.write(string, encoding, offset[, length]) is no longer supported');}\n\n\n\n  var remaining = this.length - offset;\n  if (length === undefined || length > remaining) length = remaining;\n\n  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds');}\n\n\n  if (!encoding) encoding = 'utf8';\n\n  var loweredCase = false;\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length);\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length);\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length);\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length);\n\n      case 'base64': /* Warning: maxLength not taken into account in base64Write*/\n\n        return base64Write(this, string, offset, length);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length);\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = ('' + encoding).toLowerCase();\n        loweredCase = true;}}};\n\n\n\n\nBuffer.prototype.toJSON = function toJSON() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0) };};\n\n\n\nfunction base64Slice(buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf);} else\n  {\n    return base64.fromByteArray(buf.slice(start, end));}}\n\n\n\nfunction utf8Slice(buf, start, end) {\n  end = Math.min(buf.length, end);\n  var res = [];\n\n  var i = start;\n  while (i < end) {\n    var firstByte = buf[i];\n    var codePoint = null;\n    var bytesPerSequence = firstByte > 0xEF ? 4 :\n    firstByte > 0xDF ? 3 :\n    firstByte > 0xBF ? 2 :\n    1;\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte;}\n\n          break;\n        case 2:\n          secondByte = buf[i + 1];\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint;}}\n\n\n          break;\n        case 3:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint;}}\n\n\n          break;\n        case 4:\n          secondByte = buf[i + 1];\n          thirdByte = buf[i + 2];\n          fourthByte = buf[i + 3];\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint;}}}}\n\n\n\n\n\n    if (codePoint === null) {/* we did not generate a valid codePoint so insert a*/ /* replacement char (U+FFFD) and advance only 1 byte*/\n\n\n      codePoint = 0xFFFD;\n      bytesPerSequence = 1;} else\n    if (codePoint > 0xFFFF) {/* encode to utf16 (surrogate pair dance)*/\n\n      codePoint -= 0x10000;\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n      codePoint = 0xDC00 | codePoint & 0x3FF;}\n\n\n    res.push(codePoint);\n    i += bytesPerSequence;}\n\n\n  return decodeCodePointsArray(res);} /* Based on http://stackoverflow.com/a/22747272/680742, the browser with*/ /* the lowest limit is Chrome, with 0x10000 args.*/ /* We go 1 magnitude less, for safety*/\n\n\n\n\n\nvar MAX_ARGUMENTS_LENGTH = 0x1000;\n\nfunction decodeCodePointsArray(codePoints) {\n  var len = codePoints.length;\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints); /* avoid extra slice()*/} /* Decode in chunks to avoid \"call stack size exceeded\".*/\n\n\n\n  var res = '';\n  var i = 0;\n  while (i < len) {\n    res += String.fromCharCode.apply(\n    String,\n    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));}\n\n\n  return res;}\n\n\nfunction asciiSlice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F);}\n\n  return ret;}\n\n\nfunction latin1Slice(buf, start, end) {\n  var ret = '';\n  end = Math.min(buf.length, end);\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i]);}\n\n  return ret;}\n\n\nfunction hexSlice(buf, start, end) {\n  var len = buf.length;\n\n  if (!start || start < 0) start = 0;\n  if (!end || end < 0 || end > len) end = len;\n\n  var out = '';\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i]);}\n\n  return out;}\n\n\nfunction utf16leSlice(buf, start, end) {\n  var bytes = buf.slice(start, end);\n  var res = '';\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);}\n\n  return res;}\n\n\nBuffer.prototype.slice = function slice(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = end === undefined ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0) start = 0;} else\n  if (start > len) {\n    start = len;}\n\n\n  if (end < 0) {\n    end += len;\n    if (end < 0) end = 0;} else\n  if (end > len) {\n    end = len;}\n\n\n  if (end < start) end = start;\n\n  var newBuf;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end);\n    newBuf.__proto__ = Buffer.prototype;} else\n  {\n    var sliceLen = end - start;\n    newBuf = new Buffer(sliceLen, undefined);\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start];}}\n\n\n\n  return newBuf;}; /* * Need to make sure that buffer isn't trying to write out of bounds.\n                    */\n\n\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');}\n\n\nBuffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;}\n\n\n  return val;};\n\n\nBuffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length);}\n\n\n  var val = this[offset + --byteLength];\n  var mul = 1;\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul;}\n\n\n  return val;};\n\n\nBuffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  return this[offset];};\n\n\nBuffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] | this[offset + 1] << 8;};\n\n\nBuffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  return this[offset] << 8 | this[offset + 1];};\n\n\nBuffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return (this[offset] |\n  this[offset + 1] << 8 |\n  this[offset + 2] << 16) +\n  this[offset + 3] * 0x1000000;};\n\n\nBuffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] * 0x1000000 + (\n  this[offset + 1] << 16 |\n  this[offset + 2] << 8 |\n  this[offset + 3]);};\n\n\nBuffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var val = this[offset];\n  var mul = 1;\n  var i = 0;\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul;}\n\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;};\n\n\nBuffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) checkOffset(offset, byteLength, this.length);\n\n  var i = byteLength;\n  var mul = 1;\n  var val = this[offset + --i];\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul;}\n\n  mul *= 0x80;\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n\n  return val;};\n\n\nBuffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length);\n  if (!(this[offset] & 0x80)) return this[offset];\n  return (0xff - this[offset] + 1) * -1;};\n\n\nBuffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset] | this[offset + 1] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;};\n\n\nBuffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | this[offset] << 8;\n  return val & 0x8000 ? val | 0xFFFF0000 : val;};\n\n\nBuffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] |\n  this[offset + 1] << 8 |\n  this[offset + 2] << 16 |\n  this[offset + 3] << 24;};\n\n\nBuffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n\n  return this[offset] << 24 |\n  this[offset + 1] << 16 |\n  this[offset + 2] << 8 |\n  this[offset + 3];};\n\n\nBuffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, true, 23, 4);};\n\n\nBuffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length);\n  return ieee754.read(this, offset, false, 23, 4);};\n\n\nBuffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, true, 52, 8);};\n\n\nBuffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length);\n  return ieee754.read(this, offset, false, 52, 8);};\n\n\nfunction checkInt(buf, value, offset, ext, max, min) {\n  if (!internalIsBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');}\n\n\nBuffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);}\n\n\n  var mul = 1;\n  var i = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;}\n\n\n  return offset + byteLength;};\n\n\nBuffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  byteLength = byteLength | 0;\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n    checkInt(this, value, offset, byteLength, maxBytes, 0);}\n\n\n  var i = byteLength - 1;\n  var mul = 1;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = value / mul & 0xFF;}\n\n\n  return offset + byteLength;};\n\n\nBuffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  this[offset] = value & 0xff;\n  return offset + 1;};\n\n\nfunction objectWriteUInt16(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>>\n    (littleEndian ? i : 1 - i) * 8;}}\n\n\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;} else\n  {\n    objectWriteUInt16(this, value, offset, true);}\n\n  return offset + 2;};\n\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;} else\n  {\n    objectWriteUInt16(this, value, offset, false);}\n\n  return offset + 2;};\n\n\nfunction objectWriteUInt32(buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1;\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;}}\n\n\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = value >>> 24;\n    this[offset + 2] = value >>> 16;\n    this[offset + 1] = value >>> 8;\n    this[offset] = value & 0xff;} else\n  {\n    objectWriteUInt32(this, value, offset, true);}\n\n  return offset + 4;};\n\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;} else\n  {\n    objectWriteUInt32(this, value, offset, false);}\n\n  return offset + 4;};\n\n\nBuffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);}\n\n\n  var i = 0;\n  var mul = 1;\n  var sub = 0;\n  this[offset] = value & 0xFF;\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1;}\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;}\n\n\n  return offset + byteLength;};\n\n\nBuffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1);\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit);}\n\n\n  var i = byteLength - 1;\n  var mul = 1;\n  var sub = 0;\n  this[offset + i] = value & 0xFF;\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1;}\n\n    this[offset + i] = (value / mul >> 0) - sub & 0xFF;}\n\n\n  return offset + byteLength;};\n\n\nBuffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);\n  if (value < 0) value = 0xff + value + 1;\n  this[offset] = value & 0xff;\n  return offset + 1;};\n\n\nBuffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;} else\n  {\n    objectWriteUInt16(this, value, offset, true);}\n\n  return offset + 2;};\n\n\nBuffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 8;\n    this[offset + 1] = value & 0xff;} else\n  {\n    objectWriteUInt16(this, value, offset, false);}\n\n  return offset + 2;};\n\n\nBuffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value & 0xff;\n    this[offset + 1] = value >>> 8;\n    this[offset + 2] = value >>> 16;\n    this[offset + 3] = value >>> 24;} else\n  {\n    objectWriteUInt32(this, value, offset, true);}\n\n  return offset + 4;};\n\n\nBuffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n  value = +value;\n  offset = offset | 0;\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  if (value < 0) value = 0xffffffff + value + 1;\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = value >>> 24;\n    this[offset + 1] = value >>> 16;\n    this[offset + 2] = value >>> 8;\n    this[offset + 3] = value & 0xff;} else\n  {\n    objectWriteUInt32(this, value, offset, false);}\n\n  return offset + 4;};\n\n\nfunction checkIEEE754(buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range');\n  if (offset < 0) throw new RangeError('Index out of range');}\n\n\nfunction writeFloat(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);}\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4);\n  return offset + 4;}\n\n\nBuffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert);};\n\n\nBuffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert);};\n\n\nfunction writeDouble(buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);}\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8);\n  return offset + 8;}\n\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert);};\n\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert);}; /* copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)*/\n\n\n\nBuffer.prototype.copy = function copy(target, targetStart, start, end) {\n  if (!start) start = 0;\n  if (!end && end !== 0) end = this.length;\n  if (targetStart >= target.length) targetStart = target.length;\n  if (!targetStart) targetStart = 0;\n  if (end > 0 && end < start) end = start; /* Copy 0 bytes; we're done*/\n\n\n  if (end === start) return 0;\n  if (target.length === 0 || this.length === 0) return 0; /* Fatal error conditions*/\n\n\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds');}\n\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');\n  if (end < 0) throw new RangeError('sourceEnd out of bounds'); /* Are we oob?*/\n\n\n  if (end > this.length) end = this.length;\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start;}\n\n\n  var len = end - start;\n  var i;\n\n  if (this === target && start < targetStart && targetStart < end) {/* descending copy from end*/\n\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start];}} else\n\n  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {/* ascending copy from start*/\n\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start];}} else\n\n  {\n    Uint8Array.prototype.set.call(\n    target,\n    this.subarray(start, start + len),\n    targetStart);}\n\n\n\n  return len;}; /* Usage:*/ /* buffer.fill(number[, offset[, end]])*/ /* buffer.fill(buffer[, offset[, end]])*/ /* buffer.fill(string[, offset[, end]][, encoding])*/\n\n\n\n\n\n\nBuffer.prototype.fill = function fill(val, start, end, encoding) {/* Handle string cases:*/\n\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start;\n      start = 0;\n      end = this.length;} else\n    if (typeof end === 'string') {\n      encoding = end;\n      end = this.length;}\n\n    if (val.length === 1) {\n      var code = val.charCodeAt(0);\n      if (code < 256) {\n        val = code;}}\n\n\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string');}\n\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding);}} else\n\n  if (typeof val === 'number') {\n    val = val & 255;} /* Invalid ranges are not set to a default, so can range check early.*/\n\n\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index');}\n\n\n  if (end <= start) {\n    return this;}\n\n\n  start = start >>> 0;\n  end = end === undefined ? this.length : end >>> 0;\n\n  if (!val) val = 0;\n\n  var i;\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val;}} else\n\n  {\n    var bytes = internalIsBuffer(val) ?\n    val :\n    utf8ToBytes(new Buffer(val, encoding).toString());\n    var len = bytes.length;\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len];}}\n\n\n\n  return this;}; /* HELPER FUNCTIONS*/ /* ================*/\n\n\n\n\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g;\n\nfunction base64clean(str) {/* Node strips out invalid characters like \\n and \\t from the string, base64-js does not*/\n\n  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); /* Node converts strings with length < 2 to ''*/\n\n  if (str.length < 2) return ''; /* Node allows for non-padded base64 strings (missing trailing ===), base64-js does not*/\n\n  while (str.length % 4 !== 0) {\n    str = str + '=';}\n\n  return str;}\n\n\nfunction stringtrim(str) {\n  if (str.trim) return str.trim();\n  return str.replace(/^\\s+|\\s+$/g, '');}\n\n\nfunction toHex(n) {\n  if (n < 16) return '0' + n.toString(16);\n  return n.toString(16);}\n\n\nfunction utf8ToBytes(string, units) {\n  units = units || Infinity;\n  var codePoint;\n  var length = string.length;\n  var leadSurrogate = null;\n  var bytes = [];\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i); /* is surrogate component*/\n\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {/* last char was a lead*/\n\n      if (!leadSurrogate) {/* no lead yet*/\n\n        if (codePoint > 0xDBFF) {/* unexpected trail*/\n\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;} else\n        if (i + 1 === length) {/* unpaired lead*/\n\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n          continue;} /* valid lead*/\n\n\n\n        leadSurrogate = codePoint;\n\n        continue;} /* 2 leads in a row*/\n\n\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n        leadSurrogate = codePoint;\n        continue;} /* valid surrogate pair*/\n\n\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;} else\n    if (leadSurrogate) {/* valid bmp char, but last char was a lead*/\n\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);}\n\n\n    leadSurrogate = null; /* encode utf8*/\n\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break;\n      bytes.push(codePoint);} else\n    if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break;\n      bytes.push(\n      codePoint >> 0x6 | 0xC0,\n      codePoint & 0x3F | 0x80);} else\n\n    if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break;\n      bytes.push(\n      codePoint >> 0xC | 0xE0,\n      codePoint >> 0x6 & 0x3F | 0x80,\n      codePoint & 0x3F | 0x80);} else\n\n    if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break;\n      bytes.push(\n      codePoint >> 0x12 | 0xF0,\n      codePoint >> 0xC & 0x3F | 0x80,\n      codePoint >> 0x6 & 0x3F | 0x80,\n      codePoint & 0x3F | 0x80);} else\n\n    {\n      throw new Error('Invalid code point');}}\n\n\n\n  return bytes;}\n\n\nfunction asciiToBytes(str) {\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {/* Node's code seems to be doing this and not & 0x7F..*/\n\n    byteArray.push(str.charCodeAt(i) & 0xFF);}\n\n  return byteArray;}\n\n\nfunction utf16leToBytes(str, units) {\n  var c, hi, lo;\n  var byteArray = [];\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break;\n\n    c = str.charCodeAt(i);\n    hi = c >> 8;\n    lo = c % 256;\n    byteArray.push(lo);\n    byteArray.push(hi);}\n\n\n  return byteArray;}\n\n\n\nfunction base64ToBytes(str) {\n  return base64.toByteArray(base64clean(str));}\n\n\nfunction blitBuffer(src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if (i + offset >= dst.length || i >= src.length) break;\n    dst[i + offset] = src[i];}\n\n  return i;}\n\n\nfunction isnan(val) {\n  return val !== val; /* eslint-disable-line no-self-compare*/} /* the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence*/ /* The _isBuffer check is for Safari 5-7 support, because it's missing*/ /* Object.prototype.constructor. Remove this eventually*/\n\n\n\n\n\n\nfunction isBuffer(obj) {\n  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));}\n\n\nfunction isFastBuffer(obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);} /* For Node v0.10 support. Remove this eventually.*/\n\n\n\nfunction isSlowBuffer(obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));}exports.Buffer = Buffer;exports.INSPECT_MAX_BYTES = INSPECT_MAX_BYTES;exports.SlowBuffer = SlowBuffer;exports.isBuffer = isBuffer;exports.kMaxLength = _kMaxLength;",
  "node_modules/process-es6/browser.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var global = require('../rollup-plugin-node-globals/src/global.js'); /* shim for using process in browser*/ /* based off https://github.com/defunctzombie/node-process/blob/master/browser.js*/\n\n\nfunction defaultSetTimout() {\n  throw new Error('setTimeout has not been defined');}\n\nfunction defaultClearTimeout() {\n  throw new Error('clearTimeout has not been defined');}\n\nvar cachedSetTimeout = defaultSetTimout;\nvar cachedClearTimeout = defaultClearTimeout;\nif (typeof global.default.setTimeout === 'function') {\n  cachedSetTimeout = setTimeout;}\n\nif (typeof global.default.clearTimeout === 'function') {\n  cachedClearTimeout = clearTimeout;}\n\n\nfunction runTimeout(fun) {\n  if (cachedSetTimeout === setTimeout) {/*normal enviroments in sane situations*/\n\n    return setTimeout(fun, 0);} /* if setTimeout wasn't available but was latter defined*/\n\n\n  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n    cachedSetTimeout = setTimeout;\n    return setTimeout(fun, 0);}\n\n  try {/* when when somebody has screwed with setTimeout but no I.E. maddness*/\n\n    return cachedSetTimeout(fun, 0);}\n  catch (e) {\n    try {/* When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally*/\n\n      return cachedSetTimeout.call(null, fun, 0);}\n    catch (e) {/* same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error*/\n\n      return cachedSetTimeout.call(this, fun, 0);}}}\n\n\n\n\n\nfunction runClearTimeout(marker) {\n  if (cachedClearTimeout === clearTimeout) {/*normal enviroments in sane situations*/\n\n    return clearTimeout(marker);} /* if clearTimeout wasn't available but was latter defined*/\n\n\n  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n    cachedClearTimeout = clearTimeout;\n    return clearTimeout(marker);}\n\n  try {/* when when somebody has screwed with setTimeout but no I.E. maddness*/\n\n    return cachedClearTimeout(marker);}\n  catch (e) {\n    try {/* When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally*/\n\n      return cachedClearTimeout.call(null, marker);}\n    catch (e) {/* same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.*/ /* Some versions of I.E. have different rules for clearTimeout vs setTimeout*/\n\n\n      return cachedClearTimeout.call(this, marker);}}}\n\n\n\n\n\n\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;}\n\n  draining = false;\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);} else\n  {\n    queueIndex = -1;}\n\n  if (queue.length) {\n    drainQueue();}}\n\n\n\nfunction drainQueue() {\n  if (draining) {\n    return;}\n\n  var timeout = runTimeout(cleanUpNextTick);\n  draining = true;\n\n  var len = queue.length;\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n    while (++queueIndex < len) {\n      if (currentQueue) {\n        currentQueue[queueIndex].run();}}\n\n\n    queueIndex = -1;\n    len = queue.length;}\n\n  currentQueue = null;\n  draining = false;\n  runClearTimeout(timeout);}\n\nfunction nextTick(fun) {\n  var args = new Array(arguments.length - 1);\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];}}\n\n\n  queue.push(new Item(fun, args));\n  if (queue.length === 1 && !draining) {\n    runTimeout(drainQueue);}} /* v8 likes predictible objects*/\n\n\n\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;}\n\nItem.prototype.run = function () {\n  this.fun.apply(null, this.array);};var\n\ntitle = 'browser';var\nplatform = 'browser';var\nbrowser = true;var\nenv = {};var\nargv = [];var\nversion = ''; /* empty string to avoid regexp issues*/var\nversions = {};var\nrelease = {};var\nconfig = {};\n\nfunction noop() {}var\n\non = noop;var\naddListener = noop;var\nonce = noop;var\noff = noop;var\nremoveListener = noop;var\nremoveAllListeners = noop;var\nemit = noop;\n\nfunction binding(name) {\n  throw new Error('process.binding is not supported');}\n\n\nfunction cwd() {return '/';}\nfunction chdir(dir) {\n  throw new Error('process.chdir is not supported');}\n;\nfunction umask() {return 0;} /* from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js*/\n\n\nvar performance = global.default.performance || {};\nvar performanceNow =\nperformance.now ||\nperformance.mozNow ||\nperformance.msNow ||\nperformance.oNow ||\nperformance.webkitNow ||\nfunction () {return new Date().getTime();}; /* generate timestamp or delta*/ /* see http://nodejs.org/api/process.html#process_process_hrtime*/\n\n\n\nfunction hrtime(previousTimestamp) {\n  var clocktime = performanceNow.call(performance) * 1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;}}\n\n\n  return [seconds, nanoseconds];}\n\n\nvar startTime = new Date();\nfunction uptime() {\n  var currentTime = new Date();\n  var dif = currentTime - startTime;\n  return dif / 1000;}\n\n\nvar process = {\n  nextTick: nextTick,\n  title: title,\n  browser: browser,\n  env: env,\n  argv: argv,\n  version: version,\n  versions: versions,\n  on: on,\n  addListener: addListener,\n  once: once,\n  off: off,\n  removeListener: removeListener,\n  removeAllListeners: removeAllListeners,\n  emit: emit,\n  binding: binding,\n  cwd: cwd,\n  chdir: chdir,\n  umask: umask,\n  hrtime: hrtime,\n  platform: platform,\n  release: release,\n  config: config,\n  uptime: uptime };exports.addListener = addListener;exports.argv = argv;exports.binding = binding;exports.browser = browser;exports.chdir = chdir;exports.config = config;exports.cwd = cwd;exports.default = process;exports.emit = emit;exports.env = env;exports.hrtime = hrtime;exports.nextTick = nextTick;exports.off = off;exports.on = on;exports.once = once;exports.platform = platform;exports.release = release;exports.removeAllListeners = removeAllListeners;exports.removeListener = removeListener;exports.title = title;exports.umask = umask;exports.uptime = uptime;exports.version = version;exports.versions = versions;",
  "node_modules/rollup-plugin-node-builtins/src/es6/inherits.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });\nvar inherits;\nif (typeof Object.create === 'function') {\n  inherits = function inherits(ctor, superCtor) {\n    /* implementation from standard node.js 'util' module*/\n    ctor.super_ = superCtor;\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true } });};} else\n\n\n\n{\n  inherits = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;};}\n\n\nvar inherits$1 = inherits;exports.default = inherits$1;",
  "node_modules/rollup-plugin-node-builtins/src/es6/util.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var global = require('../../../rollup-plugin-node-globals/src/global.js');var index = require('../../../buffer-es6/index.js');var browser = require('../../../process-es6/browser.js');var inherits = require('./inherits.js');\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar formatRegExp = /%[sdj%]/g;\nfunction format(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));}\n\n    return objects.join(' ');}\n\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function (x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s':return String(args[i++]);\n      case '%d':return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);}\n        catch (_) {\n          return '[Circular]';}\n\n      default:\n        return x;}});\n\n\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;} else\n    {\n      str += ' ' + inspect(x);}}\n\n\n  return str;}\n; /* Mark that a method should not be used.*/ /* Returns a modified function which warns once by default.*/ /* If --no-deprecation is set, then it is a no-op.*/\n\n\n\n\n\nfunction deprecate(fn, msg) {/* Allow for deprecating things in the process of starting up.*/\n\n  if (isUndefined(global.default.process)) {\n    return function () {\n      return deprecate(fn, msg).apply(this, arguments);};}\n\n\n\n  if (browser.default.noDeprecation === true) {\n    return fn;}\n\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (browser.default.throwDeprecation) {\n        throw new Error(msg);} else\n      if (browser.default.traceDeprecation) {\n        console.trace(msg);} else\n      {\n        console.error(msg);}\n\n      warned = true;}\n\n    return fn.apply(this, arguments);}\n\n\n  return deprecated;}\n;\n\n\nvar debugs = {};\nvar debugEnviron;\nfunction debuglog(set) {\n  if (isUndefined(debugEnviron))\n  debugEnviron = browser.default.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = 0;\n      debugs[set] = function () {\n        var msg = format.apply(null, arguments);\n        console.error('%s %d: %s', set, pid, msg);};} else\n\n    {\n      debugs[set] = function () {};}}\n\n\n  return debugs[set];}\n; /**\n  * Echos the value of a value. Trys to print the value out\n  * in the best way possible given the different types.\n  *\n  * @param {Object} obj The object to print out.\n  * @param {Object} opts Optional options object that alters the output.\n  */ /* legacy: obj, showHidden, depth, colors*/\n\n\n\n\nfunction inspect(obj, opts) {/* default options*/\n\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor }; /* legacy...*/\n\n\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {/* legacy...*/\n\n    ctx.showHidden = opts;} else\n  if (opts) {/* got an \"options\" object*/\n\n    _extend(ctx, opts);} /* set default options*/\n\n\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);} /* http://en.wikipedia.org/wiki/ANSI_escape_code#graphics*/\n\n\n\ninspect.colors = {\n  'bold': [1, 22],\n  'italic': [3, 23],\n  'underline': [4, 24],\n  'inverse': [7, 27],\n  'white': [37, 39],\n  'grey': [90, 39],\n  'black': [30, 39],\n  'blue': [34, 39],\n  'cyan': [36, 39],\n  'green': [32, 39],\n  'magenta': [35, 39],\n  'red': [31, 39],\n  'yellow': [33, 39] }; /* Don't use 'blue' not visible on cmd.exe*/\n\n\n\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta', /* \"name\": intentionally not styling*/\n\n  'regexp': 'red' };\n\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n    '\\u001b[' + inspect.colors[style][1] + 'm';} else\n  {\n    return str;}}\n\n\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;}\n\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function (val, idx) {\n    hash[val] = true;});\n\n\n  return hash;}\n\n\n\nfunction formatValue(ctx, value, recurseTimes) {/* Provide a hook for user-specified inspect functions.*/ /* Check that value is an object with an inspect function on it*/\n\n\n  if (ctx.customInspect &&\n  value &&\n  isFunction(value.inspect) && /* Filter out the util module, it's inspect function is special*/\n\n  value.inspect !== inspect && /* Also filter out any prototype objects using the circular check.*/\n\n  !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);}\n\n    return ret;} /* Primitive types cannot have properties*/\n\n\n\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;} /* Look up the keys of the object.*/\n\n\n\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);} /* IE doesn't make error fields non-enumerable*/ /* http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx*/\n\n\n\n\n  if (isError(value) && (\n  keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);} /* Some type of object without properties can be shortcutted.*/\n\n\n\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');}\n\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');}\n\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');}\n\n    if (isError(value)) {\n      return formatError(value);}}\n\n\n\n  var base = '',array = false,braces = ['{', '}']; /* Make Array say that they are Array*/\n\n\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];} /* Make functions say that they are functions*/\n\n\n\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';} /* Make RegExps say that they are RegExps*/\n\n\n\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);} /* Make dates with properties first say the date*/\n\n\n\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);} /* Make error with message first say the error*/\n\n\n\n  if (isError(value)) {\n    base = ' ' + formatError(value);}\n\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];}\n\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');} else\n    {\n      return ctx.stylize('[Object]', 'special');}}\n\n\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);} else\n  {\n    output = keys.map(function (key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);});}\n\n\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);}\n\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n  return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').\n    replace(/'/g, \"\\\\'\").\n    replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');}\n\n  if (isNumber(value))\n  return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n  return ctx.stylize('' + value, 'boolean'); /* For some reason typeof null is \"object\", so special case here.*/\n\n  if (isNull(value))\n  return ctx.stylize('null', 'null');}\n\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';}\n\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n      String(i), true));} else\n    {\n      output.push('');}}\n\n\n  keys.forEach(function (key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n      key, true));}});\n\n\n  return output;}\n\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');} else\n    {\n      str = ctx.stylize('[Getter]', 'special');}} else\n\n  {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');}}\n\n\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';}\n\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);} else\n      {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);}\n\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function (line) {\n            return '  ' + line;}).\n          join('\\n').substr(2);} else\n        {\n          str = '\\n' + str.split('\\n').map(function (line) {\n            return '   ' + line;}).\n          join('\\n');}}} else\n\n\n    {\n      str = ctx.stylize('[Circular]', 'special');}}\n\n\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;}\n\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');} else\n    {\n      name = name.replace(/'/g, \"\\\\'\").\n      replace(/\\\\\"/g, '\"').\n      replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');}}\n\n\n\n  return name + ': ' + str;}\n\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function (prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;},\n  0);\n\n  if (length > 60) {\n    return braces[0] + (\n    base === '' ? '' : base + '\\n ') +\n    ' ' +\n    output.join(',\\n  ') +\n    ' ' +\n    braces[1];}\n\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];} /* NOTE: These type checking functions intentionally don't use `instanceof`*/ /* because it is fragile and can be easily faked with `Object.create()`.*/\n\n\n\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar);}\n\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';}\n\n\nfunction isNull(arg) {\n  return arg === null;}\n\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;}\n\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';}\n\n\nfunction isString(arg) {\n  return typeof arg === 'string';}\n\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';}\n\n\nfunction isUndefined(arg) {\n  return arg === void 0;}\n\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';}\n\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;}\n\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';}\n\n\nfunction isError(e) {\n  return isObject(e) && (\n  objectToString(e) === '[object Error]' || e instanceof Error);}\n\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';}\n\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n  typeof arg === 'boolean' ||\n  typeof arg === 'number' ||\n  typeof arg === 'string' ||\n  typeof arg === 'symbol' || /* ES6 symbol*/\n  typeof arg === 'undefined';}\n\n\nfunction isBuffer(maybeBuf) {\n  return index.isBuffer(maybeBuf);}\n\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);}\n\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);}\n\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n'Oct', 'Nov', 'Dec']; /* 26 Feb 16:19:34*/\n\n\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n  pad(d.getMinutes()),\n  pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');} /* log is just a thin wrapper to console.log that prepends a timestamp*/\n\n\n\n\nfunction log() {\n  console.log('%s - %s', timestamp(), format.apply(null, arguments));}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction _extend(origin, add) {/* Don't do anything if add isn't an object*/\n\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];}\n\n  return origin;}\n;\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);}\n\n\nvar util = {\n  inherits: inherits.default,\n  _extend: _extend,\n  log: log,\n  isBuffer: isBuffer,\n  isPrimitive: isPrimitive,\n  isFunction: isFunction,\n  isError: isError,\n  isDate: isDate,\n  isObject: isObject,\n  isRegExp: isRegExp,\n  isUndefined: isUndefined,\n  isSymbol: isSymbol,\n  isString: isString,\n  isNumber: isNumber,\n  isNullOrUndefined: isNullOrUndefined,\n  isNull: isNull,\n  isBoolean: isBoolean,\n  isArray: isArray,\n  inspect: inspect,\n  deprecate: deprecate,\n  format: format,\n  debuglog: debuglog };exports.inherits = inherits.default;exports._extend = _extend;exports.debuglog = debuglog;exports.default = util;exports.deprecate = deprecate;exports.format = format;exports.inspect = inspect;exports.isArray = isArray;exports.isBoolean = isBoolean;exports.isBuffer = isBuffer;exports.isDate = isDate;exports.isError = isError;exports.isFunction = isFunction;exports.isNull = isNull;exports.isNullOrUndefined = isNullOrUndefined;exports.isNumber = isNumber;exports.isObject = isObject;exports.isPrimitive = isPrimitive;exports.isRegExp = isRegExp;exports.isString = isString;exports.isSymbol = isSymbol;exports.isUndefined = isUndefined;exports.log = log;",
  "node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/buffer-list.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var index = require('../../../../buffer-es6/index.js');\n\n\n\nfunction BufferList() {\n  this.head = null;\n  this.tail = null;\n  this.length = 0;}\n\n\nBufferList.prototype.push = function (v) {\n  var entry = { data: v, next: null };\n  if (this.length > 0) this.tail.next = entry;else this.head = entry;\n  this.tail = entry;\n  ++this.length;};\n\n\nBufferList.prototype.unshift = function (v) {\n  var entry = { data: v, next: this.head };\n  if (this.length === 0) this.tail = entry;\n  this.head = entry;\n  ++this.length;};\n\n\nBufferList.prototype.shift = function () {\n  if (this.length === 0) return;\n  var ret = this.head.data;\n  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n  --this.length;\n  return ret;};\n\n\nBufferList.prototype.clear = function () {\n  this.head = this.tail = null;\n  this.length = 0;};\n\n\nBufferList.prototype.join = function (s) {\n  if (this.length === 0) return '';\n  var p = this.head;\n  var ret = '' + p.data;\n  while (p = p.next) {\n    ret += s + p.data;}\n  return ret;};\n\n\nBufferList.prototype.concat = function (n) {\n  if (this.length === 0) return index.Buffer.alloc(0);\n  if (this.length === 1) return this.head.data;\n  var ret = index.Buffer.allocUnsafe(n >>> 0);\n  var p = this.head;\n  var i = 0;\n  while (p) {\n    p.data.copy(ret, i);\n    i += p.data.length;\n    p = p.next;}\n\n  return ret;};exports.default = BufferList;",
  "node_modules/rollup-plugin-node-builtins/src/es6/string-decoder.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var index = require('../../../buffer-es6/index.js'); /* Copyright Joyent, Inc. and other Node contributors.*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar isBufferEncoding = index.Buffer.isEncoding ||\nfunction (encoding) {\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':return true;\n    default:return false;}};\n\n\n\n\nfunction assertEncoding(encoding) {\n  if (encoding && !isBufferEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);}}\n\n\n\n/* StringDecoder provides an interface for efficiently splitting a series of*/\n/* buffers into a series of JS strings without breaking apart multi-byte*/\n/* characters. CESU-8 is handled as part of the UTF-8 encoding.*/\n/**/\n/* @TODO Handling all encodings inside a single object makes it very difficult*/\n/* to reason about this code, so it should be split up in the future.*/\n/* @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code*/\n/* points as used by CESU-8.*/\nfunction StringDecoder(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      /* CESU-8 represents each of Surrogate Pair by 3-bytes*/\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      /* UTF-16 represents each of Surrogate Pair by 2-bytes*/\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      /* Base-64 stores 3 bytes in 4 chars, and pads the remainder.*/\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;}\n\n\n  /* Enough space to store all bytes of a single character. UTF-8 needs 4*/\n  /* bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).*/\n  this.charBuffer = new index.Buffer(6);\n  /* Number of bytes received for the current incomplete multi-byte character.*/\n  this.charReceived = 0;\n  /* Number of bytes expected for the current incomplete multi-byte character.*/\n  this.charLength = 0;}\n;\n\n\n/* write decodes the given buffer and returns it as JS string that is*/\n/* guaranteed to not contain any partial multi-byte characters. Any partial*/\n/* character found at the end of the buffer is buffered up, and will be*/\n/* returned when calling write again with the remaining bytes.*/\n/**/\n/* Note: Converting a Buffer containing an orphan surrogate to a String*/\n/* currently works, but converting a String to a Buffer (via `new Buffer`, or*/\n/* Buffer#write) will replace incomplete surrogates with the unicode*/\n/* replacement character. See https://codereview.chromium.org/121173009/ .*/\nStringDecoder.prototype.write = function (buffer) {\n  var charStr = '';\n  /* if our last write ended with an incomplete multibyte character*/\n  while (this.charLength) {\n    /* determine how many remaining bytes this buffer has to offer for this char*/\n    var available = buffer.length >= this.charLength - this.charReceived ?\n    this.charLength - this.charReceived :\n    buffer.length;\n\n    /* add the new bytes to the char buffer*/\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      /* still not enough chars in this buffer? wait for more ...*/\n      return '';}\n\n\n    /* remove bytes belonging to the current character from the buffer*/\n    buffer = buffer.slice(available, buffer.length);\n\n    /* get the character that was split*/\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    /* CESU-8: lead surrogate (D800-DBFF) is also the incomplete character*/\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;}\n\n    this.charReceived = this.charLength = 0;\n\n    /* if there are no more bytes in this buffer, just emit our char*/\n    if (buffer.length === 0) {\n      return charStr;}\n\n    break;}\n\n\n  /* determine and set charLength / charReceived*/\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    /* buffer the incomplete character bytes we got*/\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;}\n\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  /* CESU-8: lead surrogate (D800-DBFF) is also the incomplete character*/\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);}\n\n\n  /* or just emit the charStr*/\n  return charStr;};\n\n\n/* detectIncompleteChar determines if there is an incomplete UTF-8 character at*/\n/* the end of the given buffer. If so, it sets this.charLength to the byte*/\n/* length that character, and sets this.charReceived to the number of bytes*/\n/* that are available for this character.*/\nStringDecoder.prototype.detectIncompleteChar = function (buffer) {\n  /* determine how many bytes we have to check at the end of this buffer*/\n  var i = buffer.length >= 3 ? 3 : buffer.length;\n\n  /* Figure out if one of the last i bytes of our buffer announces an*/\n  /* incomplete char.*/\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    /* See http://en.wikipedia.org/wiki/UTF-8#Description*/\n\n    /* 110XXXXX*/\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;}\n\n\n    /* 1110XXXX*/\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;}\n\n\n    /* 11110XXX*/\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;}}\n\n\n  this.charReceived = i;};\n\n\nStringDecoder.prototype.end = function (buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n  res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);}\n\n\n  return res;};\n\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);}\n\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;}\n\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;}exports.StringDecoder = StringDecoder;",
  "node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/readable.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var events = require('../events.js');var index = require('../../../../buffer-es6/index.js');var browser = require('../../../../process-es6/browser.js');var inherits = require('../inherits.js');var util = require('../util.js');var bufferList = require('./buffer-list.js');var stringDecoder = require('../string-decoder.js');var duplex = require('./duplex.js');'use strict';\n\n\nReadable.ReadableState = ReadableState;\n\n\n\n\n\n\n\nconsole.log('readable');\nvar debug = util.debuglog('stream');\ninherits.default(Readable, events.default);\n\nfunction prependListener(emitter, event, fn) {/* Sadly this is not cacheable as some libraries bundle their own*/ /* event emitter implementation with them.*/\n\n\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);} else\n  {/* This is a hack to make sure that our error handler is attached before any*/ /* userland ones.  NEVER DO THIS. This is here only because this code needs*/ /* to continue to work with older versions of Node.js that do not include*/ /* the prependListener() method. The goal is to eventually remove this hack.*/\n\n\n\n\n    if (!emitter._events || !emitter._events[event])\n    emitter.on(event, fn);else\n    if (Array.isArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);else\n\n    emitter._events[event] = [fn, emitter._events[event]];}}\n\n\nfunction listenerCount(emitter, type) {\n  return emitter.listeners(type).length;}\n\nfunction ReadableState(options, stream) {\n\n  options = options || {}; /* object stream flag. Used to make read(n) ignore n and to*/ /* make all the buffer merging and length checks go away*/\n\n\n\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof duplex.Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode; /* the point at which it stops calling _read() to fill the buffer*/ /* Note: 0 is a valid value, means \"don't call _read preemptively ever\"*/\n\n\n\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; /* cast to ints.*/\n\n\n  this.highWaterMark = ~~this.highWaterMark; /* A linked list is used to store data chunks instead of an array because the*/ /* linked list can remove elements from the beginning faster than*/ /* array.shift()*/\n\n\n\n\n  this.buffer = new bufferList.default();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; /* a flag to be able to tell if the onwrite cb is called immediately,*/ /* or on a later tick.  We set this to true at first, because any*/ /* actions that shouldn't happen until \"later\" should generally also*/ /* not happen before the first write call.*/\n\n\n\n\n\n  this.sync = true; /* whenever we return null, then we set a flag to say*/ /* that we're awaiting a 'readable' event emission.*/\n\n\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false; /* Crypto is kind of old and crusty.  Historically, its default string*/ /* encoding is 'binary' so we have to make this configurable.*/ /* Everything else in the universe uses 'utf8', though.*/\n\n\n\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; /* when piping, we only care about 'readable' events that happen*/ /* after read()ing all the bytes and not getting any pushback.*/\n\n\n\n  this.ranOut = false; /* the number of writers that are awaiting a drain event in .pipe()s*/\n\n\n  this.awaitDrain = 0; /* if true, a maybeReadMore has been scheduled*/\n\n\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    this.decoder = new stringDecoder.StringDecoder(options.encoding);\n    this.encoding = options.encoding;}}\n\n\n\nfunction Readable(options) {\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this); /* legacy*/\n\n\n  this.readable = true;\n\n  if (options && typeof options.read === 'function') this._read = options.read;\n\n  events.default.call(this);} /* Manually shove something into the read() buffer.*/ /* This returns true if the highWaterMark has not been hit yet,*/ /* similar to how Writable.write() returns true if you should*/ /* write() some more.*/\n\n\n\n\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n\n  if (!state.objectMode && typeof chunk === 'string') {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = index.Buffer.from(chunk, encoding);\n      encoding = '';}}\n\n\n\n  return readableAddChunk(this, state, chunk, encoding, false);}; /* Unshift should *always* be something directly out of read()*/\n\n\n\nReadable.prototype.unshift = function (chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);};\n\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;};\n\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);} else\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);} else\n  if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);} else\n    if (state.endEmitted && addToFront) {\n      var _e = new Error('stream.unshift() after end event');\n      stream.emit('error', _e);} else\n    {\n      var skipAdd;\n      if (state.decoder && !addToFront && !encoding) {\n        chunk = state.decoder.write(chunk);\n        skipAdd = !state.objectMode && chunk.length === 0;}\n\n\n      if (!addToFront) state.reading = false; /* Don't add to the buffer if we've decoded to an empty string chunk and*/ /* we're not in object mode*/\n\n\n\n      if (!skipAdd) {/* if we want the data now, just emit it.*/\n\n        if (state.flowing && state.length === 0 && !state.sync) {\n          stream.emit('data', chunk);\n          stream.read(0);} else\n        {/* update the buffer info.*/\n\n          state.length += state.objectMode ? 1 : chunk.length;\n          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n          if (state.needReadable) emitReadable(stream);}}\n\n\n\n      maybeReadMore(stream, state);}} else\n\n  if (!addToFront) {\n    state.reading = false;}\n\n\n  return needMoreData(state);} /* if it's past the high water mark, we can push in some more.*/ /* Also, if we have no data yet, we can stand some*/ /* more bytes.  This is to work around cases where hwm=0,*/ /* such as the repl.  Also, if the push() triggered a*/ /* readable event, and the user called read(largeNumber) such that*/ /* needReadable was set, then we ought to push more, so that another*/ /* 'readable' event will be triggered.*/\n\n\n\n\n\n\n\n\n\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);} /* backwards compatibility.*/\n\n\n\nReadable.prototype.setEncoding = function (enc) {\n  this._readableState.decoder = new stringDecoder.StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;}; /* Don't raise the hwm > 8MB*/\n\n\n\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;} else\n  {/* Get the next highest power of 2 to prevent increasing hwm excessively in*/ /* tiny amounts*/\n\n\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;}\n\n  return n;} /* This function is designed to be inlinable, so please take care when making*/ /* changes to the function body.*/\n\n\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {/* Only flow one buffer at a time*/\n\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;} /* If we're asking for more than the current hwm, then raise the hwm.*/\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; /* Don't have enough*/\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;}\n\n  return state.length;} /* you can override either this method, or the async _read(n) below.*/\n\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false; /* if we're doing read(0) to trigger a readable event, but we*/ /* already have a bunch of data in the buffer, then just trigger*/ /* the 'readable' event and move on.*/\n\n\n\n\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;}\n\n\n  n = howMuchToRead(n, state); /* if we've ended, and we're now clear, then finish it up.*/\n\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;} /* All the actual chunk generation logic needs to be*/ /* *below* the call to _read.  The reason is that in certain*/ /* synthetic stream cases, such as passthrough streams, _read*/ /* may be a completely synchronous operation which may change*/ /* the state of the read buffer, providing enough data when*/ /* before there was *not* enough.*/ /**/ /* So, the steps are:*/ /* 1. Figure out what the state of things will be after we do*/ /* a read from the buffer.*/ /**/ /* 2. If that resulting state will trigger a _read, then call _read.*/ /* Note that this may be asynchronous, or synchronous.  Yes, it is*/ /* deeply ugly to write APIs this way, but that still doesn't mean*/ /* that the Readable class should behave improperly, as streams are*/ /* designed to be sync/async agnostic.*/ /* Take note if the _read call is sync or async (ie, if the read call*/ /* has returned yet), so that we know whether or not it's safe to emit*/ /* 'readable' etc.*/ /**/ /* 3. Actually pull the requested chunks out of the buffer and return.*/ /* if we need a readable event, then we need to do some reading.*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); /* if we currently have less than the highWaterMark, then also read some*/\n\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);} /* however, if we've ended, then there's no point, and if we're already*/ /* reading, then it's unnecessary.*/\n\n\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);} else\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; /* if the length is currently zero, then we *need* a readable event.*/\n\n    if (state.length === 0) state.needReadable = true; /* call internal read method*/\n\n    this._read(state.highWaterMark);\n    state.sync = false; /* If _read pushed data synchronously, then `reading` will be false,*/ /* and we need to re-evaluate how much data we can return to the user.*/\n\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);}\n\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;} else\n  {\n    state.length -= n;}\n\n\n  if (state.length === 0) {/* If we have nothing in the buffer, then we want to know*/ /* as soon as we *do* get something into the buffer.*/\n\n\n    if (!state.ended) state.needReadable = true; /* If we tried to read() past the EOF, then emit end on the next tick.*/\n\n\n    if (nOrig !== n && state.ended) endReadable(this);}\n\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;};\n\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!index.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');}\n\n  return er;}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;}}\n\n\n  state.ended = true; /* emit 'readable' now to make sure it gets picked up.*/\n\n\n  emitReadable(stream);} /* Don't emit readable right away in sync mode, because this can trigger*/ /* another read() call => stack overflow.  This way, it might trigger*/ /* a nextTick recursion warning, but that's not so bad.*/\n\n\n\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) browser.nextTick(emitReadable_, stream);else emitReadable_(stream);}}\n\n\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);} /* at this point, the user has presumably seen the 'readable' event,*/ /* and called read() to consume some data.  that may have triggered*/ /* in turn another _read(n) call, in which case reading = true if*/ /* it's in progress.*/ /* However, if we're not ended, or reading, and the length < hwm,*/ /* then go ahead and try to read some more preemptively.*/\n\n\n\n\n\n\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    browser.nextTick(maybeReadMore_, stream, state);}}\n\n\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) /* didn't get any data, stop spinning.*/\n\n      break;else len = state.length;}\n\n  state.readingMore = false;} /* abstract method.  to be overridden in specific implementation classes.*/ /* call cb(er, data) where data is <= n in length.*/ /* for virtual (non-string, non-buffer) streams, \"length\" is somewhat*/ /* arbitrary, and perhaps not very meaningful.*/\n\n\n\n\n\n\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('not implemented'));};\n\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;}\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = !pipeOpts || pipeOpts.end !== false;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted) browser.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();}}\n\n\n\n  function onend() {\n    debug('onend');\n    dest.end();} /* when the dest drains, it reduces the awaitDrain counter*/ /* on the source.  This would be more elegant with a .once()*/ /* handler in flow(), but adding and removing repeatedly is*/ /* too slow.*/\n\n\n\n\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup'); /* cleanup event handlers once the pipe is broken*/\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true; /* if the reader is waiting for a drain event from this*/ /* specific writer, then it would cause it to never start*/ /* flowing again.*/ /* So, if this is awaiting a drain, then we just call it now.*/ /* If we don't know, then assume that we are waiting for one.*/\n\n\n\n\n\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();} /* If the user pushes more data while we're writing to dest then we'll end up*/ /* in ondata again. However, we only want to increase awaitDrain once because*/ /* dest will only emit one 'drain' event for the multiple writes.*/ /* => Introduce a guard on increasing awaitDrain.*/\n\n\n\n\n\n\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {/* If the user unpiped during `dest.write()`, it is possible*/ /* to get stuck in a permanently paused state if that write*/ /* also returned false.*/ /* => Check whether `dest` is still a piping destination.*/\n\n\n\n\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;}\n\n      src.pause();}} /* if the dest has an error, then stop piping into it.*/ /* however, don't suppress the throwing behavior for this.*/\n\n\n\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (listenerCount(dest, 'error') === 0) dest.emit('error', er);} /* Make sure our error handler is attached before userland ones.*/\n\n\n\n  prependListener(dest, 'error', onerror); /* Both close and finish should trigger unpipe, but only once.*/\n\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();}\n\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();}\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);} /* tell the dest that it's being piped to*/\n\n\n\n  dest.emit('pipe', src); /* start the flow if it hasn't been started already.*/\n\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();}\n\n\n  return dest;};\n\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && src.listeners('data').length) {\n      state.flowing = true;\n      flow(src);}};}\n\n\n\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState; /* if we're not piping anywhere, then do nothing.*/\n\n\n  if (state.pipesCount === 0) return this; /* just one destination.  most common case.*/\n\n\n  if (state.pipesCount === 1) {/* passed in one, but it's not the right one.*/\n\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes; /* got a match.*/\n\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this);\n    return this;} /* slow case. multiple pipe destinations.*/\n\n\n\n\n  if (!dest) {/* remove all.*/\n\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var _i = 0; _i < len; _i++) {\n      dests[_i].emit('unpipe', this);}\n    return this;} /* try to find the right one.*/\n\n\n\n  var i = indexOf(state.pipes, dest);\n  if (i === -1) return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;}; /* set up data events if they are asked for*/ /* Ensure readable listeners eventually get something*/\n\n\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = events.default.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {/* Start flowing on next tick if stream isn't explicitly paused*/\n\n    if (this._readableState.flowing !== false) this.resume();} else\n  if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        browser.nextTick(nReadingNextTick, this);} else\n      if (state.length) {\n        emitReadable(this, state);}}}\n\n\n\n\n  return res;};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);} /* pause() and resume() are remnants of the legacy readable stream API*/ /* If the user uses them, then switch into old mode.*/\n\n\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);}\n\n  return this;};\n\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    browser.nextTick(resume_, stream, state);}}\n\n\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);}\n\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);}\n\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');}\n\n  return this;};\n\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}} /* wrap an old-style stream as the async data source.*/ /* This is *not* part of the readable stream interface.*/ /* It is an ugly unfortunate mess of history.*/\n\n\n\n\n\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);}\n\n\n    self.push(null);});\n\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); /* don't skip over falsy values in objectMode*/\n\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();}}); /* proxy all the other methods.*/ /* important when wrapping filters and duplexes.*/\n\n\n\n\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);};}(\n\n      i);}} /* proxy certain important events.*/\n\n\n\n\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function (ev) {\n    stream.on(ev, self.emit.bind(self, ev));}); /* when we try to consume some more bytes, simply unpause the*/ /* underlying stream.*/\n\n\n\n\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();}};\n\n\n\n  return self;}; /* exposed for testing purposes only.*/\n\n\n\nReadable._fromList = fromList; /* Pluck off n bytes from an array of buffers.*/ /* Length is the combined lengths of all the buffers in the list.*/ /* This function is designed to be inlinable, so please take care when making*/ /* changes to the function body.*/\n\n\n\n\n\nfunction fromList(n, state) {/* nothing buffered*/\n\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {/* read it all, truncate the list*/\n\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();} else\n  {/* read part of list*/\n\n    ret = fromListPartial(n, state.buffer, state.decoder);}\n\n\n  return ret;} /* Extracts only enough buffered data to satisfy the amount requested.*/ /* This function is designed to be inlinable, so please take care when making*/ /* changes to the function body.*/\n\n\n\n\n\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {/* slice is the same for buffers and strings*/\n\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);} else\n  if (n === list.head.data.length) {/* first chunk is a perfect match*/\n\n    ret = list.shift();} else\n  {/* result spans more than one buffer*/\n\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);}\n\n  return ret;} /* Copies a specified amount of characters from the list of buffered data*/ /* chunks.*/ /* This function is designed to be inlinable, so please take care when making*/ /* changes to the function body.*/\n\n\n\n\n\n\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;} else\n      {\n        list.head = p;\n        p.data = str.slice(nb);}\n\n      break;}\n\n    ++c;}\n\n  list.length -= c;\n  return ret;} /* Copies a specified amount of bytes from the list of buffered data chunks.*/ /* This function is designed to be inlinable, so please take care when making*/ /* changes to the function body.*/\n\n\n\n\n\nfunction copyFromBuffer(n, list) {\n  var ret = index.Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;} else\n      {\n        list.head = p;\n        p.data = buf.slice(nb);}\n\n      break;}\n\n    ++c;}\n\n  list.length -= c;\n  return ret;}\n\n\nfunction endReadable(stream) {\n  var state = stream._readableState; /* If we get here before consuming all the bytes, then that is a*/ /* bug in node.  Should never happen.*/\n\n\n\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    browser.nextTick(endReadableNT, state, stream);}}\n\n\n\nfunction endReadableNT(state, stream) {/* Check that we didn't get one last unshift.*/\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');}}\n\n\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);}}\n\n\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;}\n\n  return -1;}exports.Readable = Readable;exports.default = Readable;",
  "node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/writable.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var events = require('../events.js');var index = require('../../../../buffer-es6/index.js');var browser = require('../../../../process-es6/browser.js');var inherits = require('../inherits.js');var util = require('../util.js');var duplex = require('./duplex.js'); /* A bit simpler than readable streams.*/\n\n\n\n\n\n\nWritable.WritableState = WritableState;\n\n\n\n\nconsole.log('writable');\ninherits.default(Writable, events.EventEmitter);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;}\n\n\nfunction WritableState(options, stream) {\n  Object.defineProperty(this, 'buffer', {\n    get: util.deprecate(function () {\n      return this.getBuffer();},\n    '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.') });\n\n  options = options || {};\n\n  /* object stream flag to indicate whether or not this stream*/\n  /* contains buffers or objects.*/\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof duplex.Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  /* the point at which write() starts returning false*/\n  /* Note: 0 is a valid value, means that we always return false if*/\n  /* the entire buffer is not flushed immediately on write()*/\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  /* cast to ints.*/\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  /* at the start of calling end()*/\n  this.ending = false;\n  /* when end() has been called, and returned*/\n  this.ended = false;\n  /* when 'finish' is emitted*/\n  this.finished = false;\n\n  /* should we decode strings into buffers before passing to _write?*/\n  /* this is here so that some node-core streams can optimize string*/\n  /* handling at a lower level.*/\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  /* Crypto is kind of old and crusty.  Historically, its default string*/\n  /* encoding is 'binary' so we have to make this configurable.*/\n  /* Everything else in the universe uses 'utf8', though.*/\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  /* not an actual buffer we keep track of, but a measurement*/\n  /* of how much we're waiting to get pushed to some underlying*/\n  /* socket or file.*/\n  this.length = 0;\n\n  /* a flag to see when we're in the middle of a write.*/\n  this.writing = false;\n\n  /* when true all writes will be buffered until .uncork() call*/\n  this.corked = 0;\n\n  /* a flag to be able to tell if the onwrite cb is called immediately,*/\n  /* or on a later tick.  We set this to true at first, because any*/\n  /* actions that shouldn't happen until \"later\" should generally also*/\n  /* not happen before the first write call.*/\n  this.sync = true;\n\n  /* a flag to know if we're processing previously buffered items, which*/\n  /* may call the _write() callback in the same tick, so that we don't*/\n  /* end up in an overlapped onwrite situation.*/\n  this.bufferProcessing = false;\n\n  /* the callback that's passed to _write(chunk,cb)*/\n  this.onwrite = function (er) {\n    onwrite(stream, er);};\n\n\n  /* the callback that the user supplies to write(chunk,encoding,cb)*/\n  this.writecb = null;\n\n  /* the amount that is being written when _write is called.*/\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  /* number of pending user-supplied write callbacks*/\n  /* this must be 0 before 'finish' can be emitted*/\n  this.pendingcb = 0;\n\n  /* emit prefinish if the only thing we're waiting for is _write cbs*/\n  /* This is relevant for synchronous Transform streams*/\n  this.prefinished = false;\n\n  /* True if the error was already emitted and should not be thrown again*/\n  this.errorEmitted = false;\n\n  /* count buffered requests*/\n  this.bufferedRequestCount = 0;\n\n  /* allocate the first CorkedRequest, there is always*/\n  /* one allocated and free to use, and we maintain at most two*/\n  this.corkedRequestsFree = new CorkedRequest(this);}\n\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;}\n\n  return out;};\n\n\n\nfunction Writable(options) {\n\n  /* Writable ctor is applied to Duplexes, though they're not*/\n  /* instanceof Writable, they're instanceof Readable.*/\n  if (!(this instanceof Writable) && !(this instanceof duplex.Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  /* legacy.*/\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;}\n\n\n  events.EventEmitter.call(this);}\n\n\n/* Otherwise people can pipe Writable streams, which is just wrong.*/\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));};\n\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  /* TODO: defer error events consistently everywhere, not just the cb*/\n  stream.emit('error', er);\n  browser.nextTick(cb, er);}\n\n\n/* If we get something that is not a buffer, string, null, or undefined,*/\n/* and we're not in objectMode, then that's an error.*/\n/* Otherwise stream chunks are all considered to be of length=1, and the*/\n/* watermarks determine how many objects to keep in the buffer, rather than*/\n/* how many bytes or characters.*/\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n  /* Always throw error if a null is written*/\n  /* if we are not in object mode then throw*/\n  /* if it is not a buffer, string, or undefined.*/\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');} else\n  if (!index.Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');}\n\n  if (er) {\n    stream.emit('error', er);\n    browser.nextTick(cb, er);\n    valid = false;}\n\n  return valid;}\n\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;}\n\n\n  if (index.Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);}\n\n\n  return ret;};\n\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;};\n\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);}};\n\n\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  /* node::ParseEncoding() requires lower case.*/\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;};\n\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = index.Buffer.from(chunk, encoding);}\n\n  return chunk;}\n\n\n/* if we're already writing something, then just put this*/\n/* in the queue, and wait our turn.  Otherwise, call _write*/\n/* If we return false, then we need a drain event, so set that flag.*/\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (index.Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  /* we must ensure that previous needDrain will not be reset to false.*/\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;} else\n    {\n      state.bufferedRequest = state.lastBufferedRequest;}\n\n    state.bufferedRequestCount += 1;} else\n  {\n    doWrite(stream, state, false, len, chunk, encoding, cb);}\n\n\n  return ret;}\n\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;}\n\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) browser.nextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);}\n\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;}\n\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    /* Check if we're actually ready to finish, but don't emit yet*/\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);}\n\n\n    if (sync) {\n      /*<replacement>*/\n      browser.nextTick(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/} else\n    {\n      afterWrite(stream, state, finished, cb);}}}\n\n\n\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);}\n\n\n/* Must force callback to be called on nextTick, so that we don't*/\n/* emit 'drain' before the write() consumer gets the 'false' return*/\n/* value, and has a chance to attach a 'drain' listener.*/\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');}}\n\n\n\n/* if there's something in the buffer waiting, then process it*/\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    /* Fast case, write everything using _writev()*/\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;}\n\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    /* doWrite is almost always async, defer these to save a bit of time*/\n    /* as the hot path ends with doWrite*/\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;} else\n    {\n      state.corkedRequestsFree = new CorkedRequest(state);}} else\n\n  {\n    /* Slow case, write chunks one-by-one*/\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      /* if we didn't call the onwrite immediately, then*/\n      /* it means that we need to wait until it does.*/\n      /* also, that means that the chunk and cb are currently*/\n      /* being processed, so move the buffer counter past them.*/\n      if (state.writing) {\n        break;}}\n\n\n\n    if (entry === null) state.lastBufferedRequest = null;}\n\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;}\n\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));};\n\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;} else\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;}\n\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  /* .end() fully uncorks*/\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();}\n\n\n  /* ignore unnecessary end() calls.*/\n  if (!state.ending && !state.finished) endWritable(this, state, cb);};\n\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;}\n\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');}}\n\n\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');} else\n    {\n      prefinish(stream, state);}}\n\n\n  return need;}\n\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) browser.nextTick(cb);else stream.once('finish', cb);}\n\n  state.ended = true;\n  stream.writable = false;}\n\n\n/* It seems a linked list but it is not*/\n/* there will be only 2 of these for each stream*/\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;}\n\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;} else\n    {\n      state.corkedRequestsFree = _this;}};}exports.Writable = Writable;exports.default = Writable;",
  "node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/duplex.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var browser = require('../../../../process-es6/browser.js');var inherits = require('../inherits.js');require('../util.js');var readable = require('./readable.js');var writable = require('./writable.js');\n\n\n\n\n\nconsole.log('duplex');\ninherits.default(Duplex, readable.Readable);\n\nvar keys = Object.keys(writable.Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = writable.Writable.prototype[method];}\n\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  readable.Readable.call(this, options);\n  writable.Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);}\n\n\n/* the no-half-open enforcer*/\nfunction onend() {\n  /* if we allow half-open state, or if the writable side ended,*/\n  /* then we're ok.*/\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  /* no more data can be written.*/\n  /* But allow more writes to happen in this tick.*/\n  browser.nextTick(onEndNT, this);}\n\n\nfunction onEndNT(self) {\n  self.end();}exports.Duplex = Duplex;exports.default = Duplex;",
  "node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/transform.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var inherits = require('../inherits.js');require('../util.js');var duplex = require('./duplex.js'); /* a transform stream is a readable/writable stream where you do*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ninherits.default(Transform, duplex.Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);};\n\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;}\n\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);}}\n\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  duplex.Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  /* when the writable side finishes, then flush out anything remaining.*/\n  var stream = this;\n\n  /* start out asking for a readable event once data is transformed.*/\n  this._readableState.needReadable = true;\n\n  /* we have implemented the _read method, and done the other things*/\n  /* that Readable wants before the first _read call, so unset the*/\n  /* sync guard flag.*/\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;}\n\n\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er) {\n      done(stream, er);});else\n    done(stream);});}\n\n\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return duplex.Duplex.prototype.push.call(this, chunk, encoding);};\n\n\n/* This is the part where you do stuff!*/\n/* override this function in implementation classes.*/\n/* 'chunk' is an input chunk.*/\n/**/\n/* Call `push(newChunk)` to pass along transformed output*/\n/* to the readable side.  You may call 'push' zero or more times.*/\n/**/\n/* Call `cb(err)` when you are done with this chunk.  If you pass*/\n/* an error, then that'll put the hurt on the whole operation.  If you*/\n/* never call cb(), then you'll never get another chunk.*/\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('Not implemented');};\n\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);}};\n\n\n\n/* Doesn't matter what the args are here.*/\n/* _transform does all the work.*/\n/* That we got here means that the readable side wants more data.*/\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);} else\n  {\n    /* mark that we need a transform, so that any data that comes in*/\n    /* will get processed, now that we've asked for it.*/\n    ts.needTransform = true;}};\n\n\n\nfunction done(stream, er) {\n  if (er) return stream.emit('error', er);\n\n  /* if there's nothing in the write buffer, then that means*/\n  /* that nothing more will ever be provided*/\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);}exports.Transform = Transform;exports.default = Transform;",
  "node_modules/rollup-plugin-node-builtins/src/es6/readable-stream/passthrough.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var inherits = require('../inherits.js');require('../util.js');var transform = require('./transform.js');\n\n\n\ninherits.default(PassThrough, transform.Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  transform.Transform.call(this, options);}\n\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);};exports.PassThrough = PassThrough;exports.default = PassThrough;",
  "node_modules/rollup-plugin-node-builtins/src/es6/stream.js": "'use strict';Object.defineProperty(exports, '__esModule', { value: true });var events = require('./events.js');var inherits = require('./inherits.js');require('./util.js');var readable = require('./readable-stream/readable.js');var writable = require('./readable-stream/writable.js');var duplex = require('./readable-stream/duplex.js');var transform = require('./readable-stream/transform.js');var passthrough = require('./readable-stream/passthrough.js');\n\n\n\n\n\n\n\n\nconsole.log('stream');\ninherits.default(Stream, events.default);\nStream.Readable = readable.Readable;\nStream.Writable = writable.Writable;\nStream.Duplex = duplex.Duplex;\nStream.Transform = transform.Transform;\nStream.PassThrough = passthrough.PassThrough;\n\n/* Backwards-compat with node 0.4.x*/\nStream.Stream = Stream;\n\n\n\n\n/* old-style streams.  Note that the pipe method (the only relevant*/\n/* part of this class) is overridden in the Readable class.*/\n\nfunction Stream() {\n  events.default.call(this);}\n\n\nStream.prototype.pipe = function (dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();}}}\n\n\n\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();}}\n\n\n\n  dest.on('drain', ondrain);\n\n  /* If the 'end' option is not supplied, dest.end() will be called when*/\n  /* source gets the 'end' or 'close' events.  Only dest.end() once.*/\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);}\n\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();}\n\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();}\n\n\n  /* don't leave dangling pipes when there are errors.*/\n  function onerror(er) {\n    cleanup();\n    if (events.default.listenerCount(this, 'error') === 0) {\n      throw er; /* Unhandled stream error in pipe.*/}}\n\n\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  /* remove all the event listeners that were added.*/\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);}\n\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  /* Allow for unix-like usage: A.pipe(B).pipe(C)*/\n  return dest;};exports.Readable = readable.Readable;exports.Writable = writable.Writable;exports.Duplex = duplex.Duplex;exports.Transform = transform.Transform;exports.PassThrough = passthrough.PassThrough;exports.Stream = Stream;exports.default = Stream;"
};
  const nsBundle = {};

  function createEvalString(filename) {
      const code = sourceBundle[filename];
      if (!code) {
        return undefined;
      }
      return `\
(function getExport(require, exports) { \
  'use strict'; \
  const module = { exports }; \
  \
  ${code}
  return module.exports;
})
//# sourceURL=${filePrefix}/${filename}
`;
    }

  function computeExports(filename, exportPowers, exports) {
      const {
        require: systemRequire,
        _log
      } = exportPowers;
      // This captures the endowed require.
      const match = filename.match(/^(.*)\/[^/]+$/);
      const thisdir = match ? match[1] : '.';
      const contextRequire = mod => {
        // Do path algebra to find the actual source.
        const els = mod.split('/');
        let prefix;
        if (els[0][0] === '@') {
          // Scoped name.
          prefix = els.splice(0, 2).join('/');
        } else if (els[0][0] === '.') {
          // Relative.
          els.unshift(...thisdir.split('/'));
        } else {
          // Bare or absolute.
          prefix = els.splice(0, 1);
        }

        const suffix = [];
        for (const el of els) {
          if (el === '.' || el === '') {
            // Do nothing.
          } else if (el === '..') {
            // Traverse upwards.
            suffix.pop();
          } else {
            suffix.push(el);
          }
        }

        // log(mod, prefix, suffix);
        if (prefix !== undefined) {
          suffix.unshift(prefix);
        }
        let modPath = suffix.join('/');
        if (modPath.startsWith('./')) {
          modPath = modPath.slice(2);
        }
        // log('requiring', modPath);
        if (!(modPath in nsBundle)) {
          // log('evaluating', modPath);
          // Break cycles, but be tolerant of modules
          // that completely override their exports object.
          nsBundle[modPath] = {};
          nsBundle[modPath] = computeExports(
            modPath,
            exportPowers,
            nsBundle[modPath],
          );
        }

        // log('returning', nsBundle[modPath]);
        return nsBundle[modPath];
      };

      const code = createEvalString(filename);
      if (!code) {
        // log('missing code for', filename, sourceBundle);
        if (systemRequire) {
          return systemRequire(filename);
        }
        throw Error(
          `require(${JSON.stringify(
            filename,
          )}) failed; no toplevel require endowment`,
        );
      }

      // log('evaluating', code);
      return nestedEvaluate(code)(contextRequire, exports);
    }

  // Evaluate the entrypoint recursively, seeding the exports.
  return computeExports(entrypoint, { require }, {});
}
//# sourceURL=/bundled-source-preamble.js
